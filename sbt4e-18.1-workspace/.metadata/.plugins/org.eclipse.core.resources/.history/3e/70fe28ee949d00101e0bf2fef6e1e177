/*
 * c_heart.c
 *
 *  Created on: 30/09/2025
 *      Author: jkim960
 */





void start_cycle(){
	if (started){
		alt_alarm_stop(&URI_LRI);
		alt_alarm_stop(&PVARP);
		alt_alarm_stop(&VRP);
		alt_alarm_stop(&AEI_AVI);
	}
	started = 1;
	alt_alarm_start(&URI_LRI, URI_VALUE, URI_LRI_interrupt, NULL);
	alt_alarm_start(&PVARP, PVARP_VALUE, PVARP_interrupt, NULL);
	alt_alarm_start(&VRP, VRP_VALUE, VRP_interrupt, NULL);
	alt_alarm_start(&AEI_AVI, AEI_VALUE, AEI_AVI_interrupt, NULL);
	ignore_a = 1;
	ignore_v = 1;
	can_vpulse = 0;
	need_v_pulse = 0;
}

alt_u32 PVARP_interrupt(){
	ignore_a = 0;
	return LRI_VALUE; // value so it does not trigger when unwanted
}

alt_u32 VRP_interrupt(){
	ignore_v = 0;
	return LRI_VALUE; // value so it does not trigger when unwanted
}

alt_u32 URI_LRI_interrupt(){
	if (!can_vpulse){ // URI timeout
		can_vpulse = 1;
		return LRI_VALUE - URI_VALUE;
	} else { // LRI timeout
		vp = 1;
		is_recent_a = 0;
		reset_cycle = 1;
		can_vpulse = 0;
		return URI_VALUE;
	}
}

alt_u32 AEI_AVI_interrupt(){
	if (is_recent_a){ // most recent is a a
		if (can_vpulse){
			vp = 1;
			is_recent_a = 0;
			reset_cycle = 1;
		} else {
			need_v_pulse = 1;
		}
		return LRI_VALUE; // large value
	} else { // most recent is a v
		ap = 1;
		is_recent_a = 1;
		return AVI_VALUE;
	}
}

void extern_v_interrupt(){
	if (!ignore_v){
		printf("vs\n");
		can_vpulse = 0;
		reset_cycle = 1;
		is_recent_a = 0;
	}
}

void extern_a_interrupt(){
	if (!ignore_a){
		alt_alarm_stop(&AEI_AVI);
		printf("as\n");
		alt_alarm_start(&AEI_AVI, AVI_VALUE, AEI_AVI_interrupt, NULL);
		is_recent_a = 1;
	}
}
//fwrite (msg, strlen (msg), 1, fp);

